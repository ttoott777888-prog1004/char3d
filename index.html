<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>char3d (Auto-load Walk.glb)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#0b1020}
    canvas{display:block}
    #ui{
      position:absolute;left:12px;top:12px;z-index:10;
      background:rgba(0,0,0,.55);color:#e7efff;
      font:13px/1.45 system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif;
      padding:10px 12px;border-radius:12px;backdrop-filter: blur(6px);
      min-width: 280px;max-width: 520px;
    }
    #title{font-weight:800;color:#fff;margin-bottom:6px}
    #status{opacity:.9;margin-bottom:10px;white-space:pre-wrap}
    .row{display:flex;flex-wrap:wrap;gap:8px}
    button{
      border:0;border-radius:10px;padding:8px 10px;cursor:pointer;
      background:#223b78;color:#fff;
    }
    button:hover{filter:brightness(1.08)}
    button:active{transform:translateY(1px)}
    .muted{opacity:.8}
    input[type="range"]{width:160px;vertical-align:middle}
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="ui">
    <div id="title">char3d (Auto)</div>
    <div id="status">로딩 준비…</div>
    <div class="row" id="buttons"></div>
    <div style="margin-top:10px" class="muted">
      키: 1~9 = 클립 전환<br/>
      페이드: <span id="fadeLabel">0.25</span>s
      <input id="fade" type="range" min="0.01" max="1.50" step="0.01" value="0.25" />
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

    // 같은 폴더( /char3d/ )에 있는 777jh.glb를 자동 로드
    const MODEL_URL = new URL("Walk.glb", window.location.href).toString();

    const statusEl = document.getElementById("status");
    const btnWrap  = document.getElementById("buttons");
    const fade     = document.getElementById("fade");
    const fadeLabel= document.getElementById("fadeLabel");
    fade.addEventListener("input", () => fadeLabel.textContent = Number(fade.value).toFixed(2));

    // ========= Scene =========
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1020);

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.01, 500);
    camera.position.set(2.2, 1.6, 3.2);

    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.HemisphereLight(0xaabfff, 0x223355, 0.8));
    const dir = new THREE.DirectionalLight(0xffffff, 1.2);
    dir.position.set(3, 8, 4);
    scene.add(dir);

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshStandardMaterial({ color: 0x0e162c, roughness: 1.0, metalness: 0.0 })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    const grid = new THREE.GridHelper(30, 30, 0x334466, 0x1b2a44);
    grid.position.y = 0.001;
    scene.add(grid);

    // ========= Animation =========
    const clock = new THREE.Clock();
    let mixer = null;
    let modelRoot = null;

    const actions = new Map(); // name -> AnimationAction
    let activeAction = null;

    function pickDefault(names){
      const low = names.map(n => (n||"").toLowerCase());
      let i = low.findIndex(n => n.includes("idle"));
      if (i >= 0) return names[i];
      i = low.findIndex(n => n.includes("walk"));
      if (i >= 0) return names[i];
      i = low.findIndex(n => n.includes("run"));
      if (i >= 0) return names[i];
      return names[0];
    }

    function setWeight(action, w){
      action.enabled = true;
      action.setEffectiveTimeScale(1);
      action.setEffectiveWeight(w);
      if (!action.isRunning()) action.play();
    }

    function fadeTo(name, duration){
      const next = actions.get(name);
      if (!next) return;
      if (activeAction === next) return;

      // 다음 액션 준비
      next.reset();
      setWeight(next, 1);
      next.play();

      // 크로스페이드
      if (activeAction) {
        activeAction.crossFadeTo(next, Math.max(0.001, duration), false);
      }

      activeAction = next;
      statusEl.textContent = `로드됨\nMODEL: ${MODEL_URL}\n클립: ${actions.size}개\n재생: ${name}`;
    }

    function buildButtons(names){
      btnWrap.innerHTML = "";
      names.forEach((name, idx) => {
        const b = document.createElement("button");
        b.textContent = `${idx+1}. ${name}`;
        b.addEventListener("click", () => fadeTo(name, Number(fade.value)));
        btnWrap.appendChild(b);
      });
    }

    function frameObject(obj){
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      // 바닥 기준: 최저점이 y=0
      obj.position.x += (obj.position.x - center.x);
      obj.position.y += (obj.position.y - box.min.y);
      obj.position.z += (obj.position.z - center.z);

      const maxSize = Math.max(size.x, size.y, size.z);
      const fitH = maxSize / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)));
      const fitW = fitH / camera.aspect;
      const dist = 1.2 * Math.max(fitH, fitW);

      const dir = new THREE.Vector3(1, 0.35, 1).normalize();
      camera.position.copy(center).addScaledVector(dir, dist);
      controls.target.set(0, Math.max(0.9, size.y * 0.55), 0);
      controls.update();
    }

    // ========= Load =========
    statusEl.textContent = `GLB 자동 로드 중…\n${MODEL_URL}`;
    const loader = new GLTFLoader();

    loader.load(
      MODEL_URL,
      (gltf) => {
        modelRoot = gltf.scene;
        scene.add(modelRoot);

        // 스킨드메쉬 컬링 방지(가끔 깜빡임 방지)
        modelRoot.traverse(o => { if (o.isSkinnedMesh) o.frustumCulled = false; });

        frameObject(modelRoot);

        mixer = new THREE.AnimationMixer(modelRoot);

        const anims = gltf.animations || [];
        if (!anims.length) {
          statusEl.textContent = `애니메이션 클립이 없습니다.\n(GLB 내 Actions 포함 필요)\nMODEL: ${MODEL_URL}`;
          return;
        }

        actions.clear();
        for (const clip of anims) {
          const name = (clip.name && clip.name.trim()) ? clip.name.trim() : `Clip_${actions.size+1}`;
          const a = mixer.clipAction(clip);
          a.loop = THREE.LoopRepeat;
          a.clampWhenFinished = false;
          actions.set(name, a);
        }

        const names = [...actions.keys()];
        buildButtons(names);

        const def = pickDefault(names);

        // 전부 재생 상태로 두되, 기본만 weight=1
        for (const [n, a] of actions.entries()) setWeight(a, n === def ? 1 : 0);
        activeAction = actions.get(def);

        statusEl.textContent = `로드 완료\nMODEL: ${MODEL_URL}\n클립: ${actions.size}개\n재생: ${def}`;
      },
      undefined,
      (err) => {
        statusEl.textContent =
          `로드 실패\nMODEL: ${MODEL_URL}\n` +
          `에러: ${(err && err.message) ? err.message : err}`;
      }
    );

    // 키 1~9로 전환
    window.addEventListener("keydown", (e) => {
      if (!actions.size) return;
      const n = Number(e.key);
      if (!Number.isFinite(n) || n < 1 || n > 9) return;
      const names = [...actions.keys()];
      const name = names[n-1];
      if (name) fadeTo(name, Number(fade.value));
    });

    // ========= Loop =========
    addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    function tick(){
      requestAnimationFrame(tick);
      const dt = clock.getDelta();
      controls.update();
      if (mixer) mixer.update(dt);
      renderer.render(scene, camera);
    }
    tick();
  </script>
</body>
</html>

